<?php
// OG audience fields query

class OgTestBase extends BackdropWebTestCase {
  public $og_entity_types;

  function setUp($modules = array()) {
    $modules = array_merge(array('entity_plus', 'entity_ui', 'entityreference', 'og', 'og_entity_test'), $modules);
    parent::setUp($modules);

    $types['main'] = entity_create('og_entity_test_type', array(
      'name' => 'main',
      'label' => t('Main test type'),
      'weight' => 0,
      'locked' => TRUE,
    ));

    // Types used during CRUD testing.
    $types['test'] = entity_create('og_entity_test_type', array(
      'name' => 'test',
      'label' => 'label',
      'weight' => 0,
    ));
    $types['test2'] = entity_create('og_entity_test_type', array(
      'name' => 'test2',
      'label' => 'label2',
      'weight' => 2,
    ));

    // This may not be necessary.
    $this->og_entity_types = $types;
  }
}

class OgAccess extends OgTestBase {

  function setUp($modules = array()) {
    parent::setUp($modules);
  }

  /**
   * Verify og_user_access_entity() returns correct value.
   */
  function testOgAccessEntity() {
    $perm = 'administer group';
    // Change permissions to authenticated member.

    // Add OG group fields.
    og_create_field(OG_GROUP_FIELD, 'og_entity_test', 'main');
    $roles = array_flip(og_roles('og_entity_test', 'main'));
    og_role_change_permissions($roles[OG_AUTHENTICATED_ROLE], array($perm => 1));


    $og_field = og_fields_info(OG_AUDIENCE_FIELD);
    $og_field['field']['settings']['target_type'] = 'og_entity_test';
    og_create_field(OG_AUDIENCE_FIELD, 'node', 'post', $og_field);

    $user1 = $this->backdropCreateUser();
    $user2 = $this->backdropCreateUser();
    $user3 = $this->backdropCreateUser();

    // Create a group.
    $entity1 = entity_create('og_entity_test', array('name' => 'main', 'uid' => $user1->uid));
    $wrapper = entity_metadata_wrapper('og_entity_test', $entity1);
    $wrapper->{OG_GROUP_FIELD}->set(1);
    $wrapper->save();

    // User has access to group.
    $this->assertTrue(og_user_access_entity($perm, 'og_entity_test', $entity1, $user1), t('User1 has access to group.'));
    $this->assertFalse(og_user_access_entity($perm, 'og_entity_test', $entity1, $user2), t('User2 does not have access to group.'));

    // User has access to a group associated with a group content.
    $settings = array();
    $settings['type'] = 'post';
    $node = $this->backdropCreateNode($settings);

    $values = array('entity_type' => 'node', 'entity' => $node);
    og_group('og_entity_test', $entity1->pid, $values);
    $this->assertTrue(og_user_access_entity($perm, 'node', $node, $user1), t('User1 has access to group content.'));
    $this->assertFalse(og_user_access_entity($perm, 'node', $node, $user2), t('User2 does not have access to group content.'));

    // Make group content also a group.
    og_create_field(OG_GROUP_FIELD, 'node', 'post');
    $og_field = og_fields_info(OG_AUDIENCE_FIELD);
    og_create_field('og_group_ref_2', 'user', 'user', $og_field);

    $settings['uid'] = $user2->uid;
    $settings[OG_GROUP_FIELD][LANGUAGE_NONE][0]['value'] = 1;
    $node = $this->backdropCreateNode($settings);

    $wrapper = entity_metadata_wrapper('node', $node);
    $wrapper->{OG_GROUP_FIELD}->set(1);
    $wrapper->save();

    $values = array('entity_type' => 'node', 'entity' => $node);
    og_group('og_entity_test', $entity1->pid, $values);

    $this->assertTrue(og_user_access_entity($perm, 'node', $node, $user1), t('User1 has access based on access to group.'));
    $this->assertTrue(og_user_access_entity($perm, 'node', $node, $user2), t('User2 has access based on access to group content.'));
    $this->assertFalse(og_user_access_entity($perm, 'node', $node, $user3), t('User3 has no access to entity.'));

    // Entity is a disabled group.
    $settings['uid'] = $user2->uid;
    $settings[OG_GROUP_FIELD][LANGUAGE_NONE][0]['value'] = 0;
    $node = $this->backdropCreateNode($settings);
    $this->assertNull(og_user_access_entity($perm, 'node', $node, $user1), t('Entity is a disabled group, so return value is NULL.'));

    // Entity is an orphan group content.
    $settings = array();
    $settings['type'] = 'post';
    $settings[OG_GROUP_FIELD][LANGUAGE_NONE][0]['value'] = 0;
    $node = $this->backdropCreateNode($settings);
    $values = array('entity_type' => 'node', 'entity' => $node);
    og_group('og_entity_test', $entity1->pid, $values);
    $entity1->delete();
    $this->assertNull(og_user_access_entity($perm, 'node', $node, $user1), t('Entity is an orphan group content, so return value is NULL.'));

    // Entity isn't a group or a group content.
    $settings = array();
    $settings[OG_GROUP_FIELD][LANGUAGE_NONE][0]['value'] = 0;
    $settings['type'] = 'post';
    $node = $this->backdropCreateNode($settings);
    $this->assertNull(og_user_access_entity($perm, 'node', $node, $user1), t('Entity is not a group or a group contentm, so return value is NULL.'));

    // Entity is NULL - as might be passed by field_access().
    $this->assertNull(og_user_access_entity($perm, 'node', NULL, $user1), t('Entity passed is NULL, so return value is NULL.'));

    // Entity is not saved to database yet.
    unset($node->nid);
    $this->assertNull(og_user_access_entity($perm, 'node', NULL, $user1), t('Entity is not saved to database, so return value is NULL.'));
  }
}

/**
 * Test Group node access. This will test nodes that are groups and group content.
 */
class OgNodeAccess extends OgTestBase {

  function setUp($modules = array()) {
    parent::setUp($modules);

    // Add OG group field to a the node's "page" bundle.
    og_create_field(OG_GROUP_FIELD, 'node', 'page');

    // Add OG audience field to the node's "post" bundle.
    og_create_field(OG_AUDIENCE_FIELD, 'node', 'post');

    // Create an editor user and a group manager for these tests.
    $this->editor_user = $this->backdropCreateUser(array('access content', 'edit any page content', 'edit any post content', 'create post content'));
    $this->group_manager = $this->backdropCreateUser(array('access content', 'create page content', 'edit own post content', 'edit own page content'));

    // Create group node.
    $settings = array(
      'type' => 'page',
      OG_GROUP_FIELD . '[und][0][value]' => 1,
      'uid' => $this->group_manager->uid
    );
    $this->group1 = $this->backdropCreateNode($settings);
    $this->group2 = $this->backdropCreateNode($settings);

    // Create node to add to group.
    $settings = array(
      'type' => 'post',
      'uid' => $this->group_manager->uid,
    );
    $this->group_content = $this->backdropCreateNode($settings);

    // Add node to group.
    $values = array(
      'entity_type' => 'node',
      'entity' => $this->group_content,
    );
    og_group('node', $this->group1, $values);
  }

  /**
   * Test strict access permissions for updating group node. A non-member of
   * a group who has core node access update permission is denied access.
   */
  function testStrictAccessNodeUpdate() {
    // Set Node access strict variable.
    config_set('og.settings', 'og_node_access_strict', TRUE);

    // Login as editor and try to change the group node and group content.
    $this->backdropLogin($this->editor_user);

    $this->backdropGet('node/' . $this->group1->nid . '/edit');
    $this->assertResponse('403', t('A non-member with core node access permissions was denied access to edit group node.'));

    $this->backdropGet('node/' . $this->group_content->nid . '/edit');
    $this->assertResponse('403', t('A non-member with core node access permissions was denied access to edit group content node.'));

    // Login as a group manager and try to change group node.
    $this->backdropLogin($this->group_manager);

    $this->backdropGet('node/' . $this->group1->nid . '/edit');
    $this->assertResponse('200', t('Group manager allowed to access to edit group node.'));

    $this->backdropGet('node/' . $this->group_content->nid . '/edit');
    $this->assertResponse('200', t('Group manager allowed to access to edit group content node.'));
  }

  /**
   * Test access to node create on strict mode.
   */
  function testStrictAccessNodeCreate() {
    // Set Node access strict variable.
    config_set('og.settings', 'og_node_access_strict', TRUE);
    $editor_user = $this->editor_user;
    $this->backdropLogin($editor_user);

    $this->backdropGet('node/add/post');
    $this->assertResponse('200', t('User can access node create with non-required field.'));

    $instance = field_info_instance('node', OG_AUDIENCE_FIELD, 'post');
    $instance['required'] = TRUE;
    field_update_instance($instance);

    $this->backdropGet('node/add/post');
    $this->assertResponse('403', t('User cannot access node create with required field.'));

    // Test OG's create permission for a group member.
    $editor_user = user_load($editor_user->uid);
    og_group('node', $this->group1, array('entity' => $editor_user));
    $roles = array_flip(og_roles('node', 'page'));

    $permissions = array(
      'create post content' => 0,
      'update own post content' => 1,
      'update any post content' => 1,
    );

    // Add update permission.
    og_role_change_permissions($roles[OG_AUTHENTICATED_ROLE], $permissions);
    $this->backdropGet('node/add/post');
    $this->assertResponse('403', 'Group member cannot create node.');

    // Add create permission.
    $permissions = array(
      'create post content' => 1,
      'update own post content' => 0,
      'update any post content' => 0,
    );
    og_role_change_permissions($roles[OG_AUTHENTICATED_ROLE], $permissions);
    $this->backdropGet('node/add/post');
    $this->assertResponse('200', 'Group member can create node.');
  }

  /**
   * Test non-strict access permissions for updating group node. A non-member
   * of a group who has core node access update permission is allowed access.
   */
  function testNoStrictAccessNodeUpdate() {
    // Set Node access strict variable.
    config_set('og.settings', 'og_node_access_strict', FALSE);

    // Login as editor and try to change the group node and group content.
    $this->backdropLogin($this->editor_user);

    $this->backdropGet('node/' . $this->group1->nid . '/edit');
    $this->assertResponse('200', t('A non-member with core node access permissions was not denied access.'));

    $this->backdropGet('node/' . $this->group_content->nid . '/edit');
    $this->assertResponse('200', t('A non-member with core node access permissions was not denied access to edit group content node.'));

    // Login as a group manager and try to change group node.
    $this->backdropLogin($this->group_manager);

    $this->backdropGet('node/' . $this->group1->nid . '/edit');
    $this->assertResponse('200', t('Group manager allowed to access to edit group node.'));

    $this->backdropGet('node/' . $this->group_content->nid . '/edit');
    $this->assertResponse('200', t('Group manager allowed to access to edit group content node.'));
  }

  /**
   * Test non-strict access permissions for creating group node.
   *
   * A member of a group who has no core node access create permission is
   * allowed access.
   */
  function testNoStrictAccessNodeCreate() {
    // Set Node access strict variable.
    config_set('og.settings', 'og_node_access_strict', FALSE);

    $this->group_editor_user = $this->backdropCreateUser(array('access content'));
    $this->backdropLogin($this->group_editor_user);

    // Test OG's create permission for a group member.
    og_group('node', $this->group1, array('entity' => $this->group_editor_user));
    $roles = array_flip(og_roles('node', 'page'));

    // Add create permission.
    $permissions = array(
      'create post content' => 1,
      'update own post content' => 0,
      'update any post content' => 0,
    );
    og_role_change_permissions($roles[OG_AUTHENTICATED_ROLE], $permissions);
    $this->backdropGet('node/add/post');
    $this->assertResponse('200', 'Group member can create node.');
  }

  /**
   * Assert a user cannot assign an existing node to a group they don't
   * have "create" permissions.
   */
  function testNodeUpdateAudienceField() {
    // Set Node access strict variable.
    config_set('og.settings', 'og_node_access_strict', TRUE);
    $editor_user = $this->editor_user;

    // Add editor to a single groups.
    og_group('node', $this->group1, array('entity' => $editor_user));
    og_group('node', $this->group2, array('entity' => $editor_user));

    // Add group-content to a single group.
    og_group('node', $this->group1, array('entity_type' => 'node', 'entity' => $this->group_content));

    // Allow member to update and create.
    $og_roles = array_flip(og_roles('node', 'page'));
    $permissions = array(
      'create post content' => 1,
      'update any post content' => 1,
    );
    og_role_change_permissions($og_roles[OG_AUTHENTICATED_ROLE], $permissions);

    // Login and try to edit this node
    $this->backdropLogin($this->editor_user);

    $this->backdropGet('node/'. $this->group_content->nid .'/edit');
    $name = 'og_group_ref[und][0][default][]';
    $xpath = $this->buildXPathQuery('//select[@name=:name]', array(':name' => $name));
    $fields = $this->xpath($xpath);
    $this->assertTrue(!empty($fields[0]->option[2]), 'User can assign group-content to a new group.');

    // Allow member to update but not create.
    $og_roles = array_flip(og_roles('node', 'page'));
    $permissions = array(
      'create post content' => 0,
      'update any post content' => 1,
    );
    og_role_change_permissions($og_roles[OG_AUTHENTICATED_ROLE], $permissions);

    $this->backdropGet('node/'. $this->group_content->nid .'/edit');
    $xpath = $this->buildXPathQuery('//select[@name=:name]', array(':name' => $name));
    $fields = $this->xpath($xpath);
    $this->assertFalse(!empty($fields[0]->option[2]), 'User cannot assign group-content to a new group.');

    // Test for retaining groups on node save.
    $this->backdropPost('node/'. $this->group_content->nid .'/edit', array(), t('Save'));

    $entity_groups = og_get_entity_groups('node', $this->group_content->nid);
    $this->assertFalse(in_array($this->group2->nid, $entity_groups['node']), 'Content retains original groups after saving node form.');
  }

}

/**
 * Test the Organic groups API and CRUD handling.
 */
class OgMetaData extends OgTestBase {

  function setUp($modules = array()) {
    parent::setUp($modules);
  }

  /**
   * Test the og_get_entity_groups() API function.
   */
  function testOgMembershipMetaData() {
    // Add OG group field to the og_entity_test's "main" bundle.
    og_create_field(OG_GROUP_FIELD, 'og_entity_test', 'main');

    // Add OG audience field to the node's "post" bundle.
    $og_field = og_fields_info(OG_AUDIENCE_FIELD);
    $og_field['field']['settings']['target_type'] = 'og_entity_test';
    og_create_field(OG_AUDIENCE_FIELD, 'node', 'post', $og_field);

    // Add a second audience field.
    og_create_field('og_ref_2', 'node', 'post', $og_field);

    $user1 = $this->backdropCreateUser();

    $entity1 = entity_create('og_entity_test', array('name' => 'main', 'uid' => $user1->uid));
    $wrapper = entity_metadata_wrapper('og_entity_test', $entity1);
    $wrapper->{OG_GROUP_FIELD}->set(1);
    $wrapper->save();

    $entity2 = entity_create('og_entity_test', array('name' => 'main', 'uid' => $user1->uid));
    $wrapper = entity_metadata_wrapper('og_entity_test', $entity2);
    $wrapper->{OG_GROUP_FIELD}->set(1);
    $wrapper->save();

    $entity3 = entity_create('og_entity_test', array('name' => 'main', 'uid' => $user1->uid));
    $wrapper = entity_metadata_wrapper('og_entity_test', $entity3);
    $wrapper->{OG_GROUP_FIELD}->set(1);
    $wrapper->save();

    $settings = array();
    $settings['type'] = 'post';

    // Create group entities.
    foreach (og_group_content_states() as $state => $value) {
      $node = $this->backdropCreateNode($settings);

      // Assign post to the group.
      $values = array('entity_type' => 'node', 'entity' => $node);
      og_group('og_entity_test', $entity1->pid, $values + array('state' => $state));
      // Subscribe node to a second group, but with a different state, by
      // selecting the state code and incrementing by one (e.g. is the
      // state is "active" then the other-state will be "pending").
      $other_state = $state == OG_STATE_BLOCKED ? OG_STATE_ACTIVE : $state + 1;
      $values += array('state' => $other_state);
      og_group('og_entity_test', $entity2->pid, $values);

      // Subscribe node to third group, using a different field.
      $values += array('field_name' => 'og_ref_2');
      og_group('og_entity_test', $entity3->pid, $values);

      $wrapper = entity_metadata_wrapper('node', $node->nid);
      $this->assertEqual($wrapper->og_membership->count(), 3, t('Found all OG memberships.'));

      $og_memberships = $wrapper->{'og_membership__' . $state}->value();
      $this->assertEqual(count($og_memberships), 1, t('Found 1 OG membership with state @state.', array('@state' => $value)));
      $this->assertEqual($og_memberships[0]->state, $state, t('OG membership has correct @state state.', array('@state' => $value)));

      $og_memberships = $wrapper->{OG_AUDIENCE_FIELD . '__og_membership__' . $state}->value();
      $this->assertEqual(count($og_memberships), 1, t('Found 1 OG membership with state @state in group-audience field.', array('@state' => $value)));
      $this->assertEqual($og_memberships[0]->field_name, OG_AUDIENCE_FIELD, t('OG membership with state @state is referencing correct field name in group-audience field.', array('@state' => $value)));
    }

    $og_memberships = $wrapper->{OG_AUDIENCE_FIELD . '__og_membership'}->value();
    $this->assertEqual(count($og_memberships), 2, t('Found 2 OG membership in group-audience field.', array('@state' => $value)));
    $this->assertEqual($og_memberships[0]->field_name, OG_AUDIENCE_FIELD, t('OG membership has correct group-audience field.'));

    $og_memberships = $wrapper->{'og_ref_2__og_membership'}->value();
    $this->assertEqual(count($og_memberships), 1, t('Found 2 OG membership in second group-audience field.', array('@state' => $value)));
    $this->assertEqual($og_memberships[0]->field_name, 'og_ref_2', t('OG membership has correct group-audience field.'));
  }
}



/**
 * Test Group content handeling.
 */
class OgGroupAndUngroup extends OgTestBase {

  function setUp($modules = array()) {
    parent::setUp($modules);

    // Add OG group field to the og_entity_test's "main" bundle.
    og_create_field(OG_GROUP_FIELD, 'og_entity_test', 'main');

    // Add OG audience field to the node's "post" bundle.
    $og_field = og_fields_info(OG_AUDIENCE_FIELD);
    $og_field['field']['settings']['target_type'] = 'og_entity_test';
    og_create_field(OG_AUDIENCE_FIELD, 'node', 'post', $og_field);
  }

  /**
   * Test group and ungroup of content.
   */
  function testGroupAndUngroup() {
    $user1 = $this->backdropCreateUser();
    $user2 = $this->backdropCreateUser();

    $entity1 = entity_create('og_entity_test', array('name' => 'main', 'uid' => $user1->uid));
    $wrapper = entity_metadata_wrapper('og_entity_test', $entity1);
    $wrapper->{OG_GROUP_FIELD}->set(1);
    $wrapper->save();

    $entity2 = entity_create('og_entity_test', array('name' => 'main', 'uid' => $user1->uid));
    $wrapper = entity_metadata_wrapper('og_entity_test', $entity2);
    $wrapper->{OG_GROUP_FIELD}->set(1);
    $wrapper->save();

    $entity3 = entity_create('og_entity_test', array('name' => 'main', 'uid' => $user1->uid));
    $wrapper = entity_metadata_wrapper('og_entity_test', $entity3);
    $wrapper->{OG_GROUP_FIELD}->set(1);
    $wrapper->save();

    $settings = array();
    $settings['type'] = 'post';
    $settings['uid'] = $user2->uid;
    $node = $this->backdropCreateNode($settings);

    // Exception on OG membership for anonymous user.
    try {
      og_membership_create('og_entity_test', $entity1->pid, 'user', 0, OG_AUDIENCE_FIELD)->save();
      $this->fail('OG membership can be created for anonymous user.');
    }
    catch (OgException $e) {
      $this->pass('OG membership can not be created for anonymous user.');
    }

    $this->assertFalse(og_is_member('og_entity_test', $entity1->pid, 'node', $node), t('Node is not assigned to group1.'));
    $values = array('entity_type' => 'node', 'entity' => $node);
    og_group('og_entity_test', $entity1->pid, $values);
    $og_membership = og_get_membership('og_entity_test', $entity1->pid, 'node', $node->nid);
    $id = $og_membership->id;
    $this->assertTrue(og_is_member('og_entity_test', $entity1->pid, 'node', $node), t('Node is assigned to group1 with active state.'));

    // State changed.
    $values += array('state' => OG_STATE_BLOCKED);
    og_group('og_entity_test', $entity1->pid, $values);
    $og_membership = og_get_membership('og_entity_test', $entity1->pid, 'node', $node->nid);
    $this->assertEqual($id, $og_membership->id, t('OG membership was updated.'));
    $this->assertTrue(og_is_member('og_entity_test', $entity1->pid, 'node', $node, array(OG_STATE_BLOCKED)), t('Node is assigned to group1 with blocked state.'));

    // Exception on existing OG membership.
    try {
      og_membership_create('og_entity_test', $entity1->pid, 'node', $node->nid, OG_AUDIENCE_FIELD)->save();
      $this->fail('Saving multiple OG membership for same entity and group works.');
    }
    catch (OgException $e) {
      $this->pass('Saving multiple OG membership for same entity and group does not work.');
    }

    // Add a second audience field.
    $og_field = og_fields_info(OG_AUDIENCE_FIELD);
    $og_field['field']['settings']['target_type'] = 'og_entity_test';
    $og_field['field']['cardinality'] = 2;
    og_create_field('og_ref_2', 'node', 'post', $og_field);

    // Re-group to another field.
    $values += array('field_name' => 'og_ref_2');
    og_group('og_entity_test', $entity1->pid, $values);
    $og_membership = og_get_membership('og_entity_test', $entity1->pid, 'node', $node->nid);
    $this->assertNotEqual($id, $og_membership->id, t('OG membership was re-created.'));
    $this->assertEqual('og_ref_2', $og_membership->field_name, t('OG membership is registered under correct field.'));


    // Exception on field cardinality.
    og_group('og_entity_test', $entity2->pid, $values);
    try {
      og_group('og_entity_test', $entity3->pid, $values);
      $this->fail('Grouping beyond field cardinality works.');
    }
    catch (OgException $e) {
      $this->pass('Grouping beyond field cardinality does not work.');
    }

    // Exception as field-name is incorrect.
    $values['field_name'] = 'wrong-field-name';
    try {
      og_group('og_entity_test', $entity1->pid, $values);
      $this->fail('Grouping with incorrect field name works.');
    }
    catch (OgException $e) {
      $this->pass('Grouping with incorrect field name does not work.');
    }

    // Exception on audience field, referencing wrong target type.
    $og_field = og_fields_info(OG_AUDIENCE_FIELD);
    $og_field['field']['settings']['target_type'] = 'node';
    og_create_field('og_ref_3', 'node', 'post', $og_field);
    $values['field_name'] = 'og_ref_3';
    try {
      og_group('og_entity_test', $entity1->pid, $values);
      $this->fail('Grouping with wrong target type works.');
    }
    catch (OgException $e) {
      $this->pass('Grouping with wrong target type does not work.');
    }

    // Exception on audience field, referencing correct target type, but wrong
    // bundles.
    $og_field = og_fields_info(OG_AUDIENCE_FIELD);
    $og_field['field']['settings']['target_type'] = 'og_entity_test';
    $og_field['field']['settings']['handler_settings']['target_bundles'] = array('test');
    og_create_field('og_ref_4', 'node', 'post', $og_field);
    $values['field_name'] = 'og_ref_4';
    try {
      og_group('og_entity_test', $entity1->pid, $values);
      $this->fail('Grouping with wrong target bundles works.');
    }
    catch (OgException $e) {
      $this->pass('Grouping with wrong target bundles does not work.');
    }


    // Exception as user has no group-audience field.
    $instance = field_info_instance('user', 'og_user_og_entity_test', 'user');
    field_delete_instance($instance);

    try {
      $entity2 = entity_create('og_entity_test', array('name' => 'main', 'uid' => $user1->uid));
      $wrapper = entity_metadata_wrapper('og_entity_test', $entity2);
      $wrapper->{OG_GROUP_FIELD}->set(1);
      $wrapper->save();
      $this->fail('Grouping with no group-audience field in bundle works.');
    }
    catch (OgException $e) {
      $this->pass('Grouping with no group-audience field in bundle does not work.');
    }

    // Ungroup node from group.
    og_ungroup('og_entity_test', $entity1->pid, 'node', $node);
    $og_membership = og_get_membership('og_entity_test', $entity1->pid, 'node', $node->nid);
    $this->assertFalse($og_membership, t('Node was ungrouped from group.'));

    // Delete node and confirm memberships were deleted.
    $values = array('entity_type' => 'node', 'entity' => $node);
    og_group('og_entity_test', $entity1->pid, $values);
    $nid = $node->nid;

    // Re-load node, to make sure we are deleting the most up-to-date one,
    // after it was altered by og_group().
    $node = node_load($nid, NULL, TRUE);
    node_delete($nid);
    $this->assertFalse(og_get_entity_groups('node', $nid), t('OG memberships deleted on entity deletion.'));

    // Test creating a non-saved OG membership.
    $settings = array();
    $settings['type'] = 'post';
    $settings['uid'] = $user2->uid;
    $node = $this->backdropCreateNode($settings);
    $values = array('entity_type' => 'node', 'entity' => $node);

    $og_membership = og_group('og_entity_test', $entity1->pid, $values);
    $this->assertTrue($og_membership->id, 'New OG membership was created and saved.');

    $settings = array();
    $settings['type'] = 'post';
    $settings['uid'] = $user2->uid;
    $node = $this->backdropCreateNode($settings);
    $values = array('entity_type' => 'node', 'entity' => $node);

    $og_membership = og_group('og_entity_test', $entity1->pid, $values, FALSE);
    $this->assertTrue(empty($og_membership->id), 'New OG membership was created but not saved.');
  }

  /**
   * Test granting deault role to group manager.
   */
  function testGroupManagerDefaultRoles() {
    // Get only the admin role.
    $og_roles = og_roles('og_entity_test', 'main', 0, FALSE, FALSE);
    config_set('og.settings', 'og_group_manager_default_rids_og_entity_test_main', array_keys($og_roles));
    $user1 = $this->backdropCreateUser();

    $entity1 = entity_create('og_entity_test', array('name' => 'main', 'uid' => $user1->uid));
    $wrapper = entity_metadata_wrapper('og_entity_test', $entity1);
    $wrapper->{OG_GROUP_FIELD}->set(1);
    $wrapper->save();

    $user_roles = og_get_user_roles('og_entity_test', $entity1->pid, $user1->uid, FALSE);
    $this->assertEqual($og_roles, $user_roles, t('Group manager was granted default role.'));
  }

  /**
   * Test group behaviour when the group owner is not active.
   */
  public function testGroupManagerNotActive() {
    // Create the user.
    $user1 = $this->backdropCreateUser();

    // Create the group; the group owner is the previously created user.
    $entity1 = entity_create('og_entity_test', array('name' => 'main', 'uid' => $user1->uid));
    $wrapper = entity_metadata_wrapper('og_entity_test', $entity1);
    $wrapper->{OG_GROUP_FIELD}->set(1);
    $wrapper->save();

    // Ensure that the user owner membership for the group has active status.
    $og_membership = og_get_membership('og_entity_test', $entity1->pid, 'user', $user1->uid);
    $this->assertEqual($og_membership->state, OG_STATE_ACTIVE, 'Owner Membership status is Active');

    // Move the user owner membership to blocked.
    $og_membership->state = OG_STATE_BLOCKED;
    $og_membership->save();

    $og_membership = og_membership_load($og_membership->id);
    $this->assertEqual($og_membership->state, OG_STATE_BLOCKED, 'Owner Membership status is Blocked');

    // Save the group entity.
    $wrapper = entity_metadata_wrapper('og_entity_test', $entity1);
    $wrapper->save();

    // Ensure that the user owner membership for the group still has blocked
    // status.
    $og_membership = og_membership_load($og_membership->id);
    $this->assertEqual($og_membership->state, OG_STATE_BLOCKED, 'Owner Membership status is Blocked');
  }

}

class OgPermissionsTestCase extends OgTestBase {

  function setUp($modules = array()) {
    parent::setUp($modules);
    // Add OG group field to the og_entity_test's "main" bundle.
    og_create_field(OG_GROUP_FIELD, 'og_entity_test', 'main');

    // Add OG audience field to the node's "post" bundle.
    $og_field = og_fields_info(OG_AUDIENCE_FIELD);
    $og_field['field']['settings']['target_type'] = 'og_entity_test';
    og_create_field(OG_AUDIENCE_FIELD, 'node', 'post', $og_field);
  }


  /**
   * Verify proper permission changes by og_role_change_permissions().
   */
  function testOgUserRoleChangePermissions() {
    // Create user.
    $user1 = $this->backdropCreateUser();

    // Create an entity.
    $entity = entity_create('og_entity_test', array('name' => 'main', 'uid' => $user1->uid));
    $wrapper = entity_metadata_wrapper('og_entity_test', $entity);
    $wrapper->{OG_GROUP_FIELD}->set(1);
    $wrapper->save();

    // Associate user to the group.
    $user2 = $this->backdropCreateUser();
    $values = array('entity_type' => 'user', 'entity' => $user2);
    og_group('og_entity_test', $entity->pid, $values);

    // Assert the user is registered to the new group.
    $this->assertTrue(og_is_member('og_entity_test', $entity->pid, 'user', $user2), t('User is registered to the new group.'));

    // Verify current permissions.
    $this->assertFalse(og_user_access('og_entity_test', $entity->pid, 'update own post content', $user2), t('User does not have "update own post content" permission.'));
    $this->assertFalse(og_user_access('og_entity_test', $entity->pid, 'delete own post content', $user2), t('User does not have "delete own post content" permission.'));

    // Change permissions to authenticated member.
    $og_roles = array_flip(og_roles('og_entity_test', 'main', $entity->pid));
    // Authenticated role ID.
    $rid = $og_roles[OG_AUTHENTICATED_ROLE];

    $permissions = array(
      'delete own post content' => 1,
    );
    og_role_change_permissions($rid, $permissions);

    // Verify proper permission changes.
    $this->assertFalse(og_user_access('og_entity_test', $entity->pid, 'update own post content', $user2), t('User still does not have "update own post content" permission.'));
    $this->assertTrue(og_user_access('og_entity_test', $entity->pid, 'delete own post content', $user2), t('User now has "delete own post content" permission.'));

    $permissions = array(
      'delete own post content' => 0,
      'administer group' => 1,
    );
    og_role_change_permissions($rid, $permissions);

    $this->assertTrue(og_user_access('og_entity_test', $entity->pid, 'delete own post content', $user2), t('User still has "delete own post content" as they have "administer group" permission.'));
    $this->assertTrue(og_user_access('og_entity_test', $entity->pid, 'administer group', $user2), t('User has "administer group" permission.'));
  }

  /**
   * Assert blocked and pending roles influence the allowed permissions.
   */
  function testBlockedAndPendingRoles() {
    // Create user.
    $user1 = $this->backdropCreateUser();

    // Create an entity.
    $entity = entity_create('og_entity_test', array('name' => 'main', 'uid' => $user1->uid));
    $wrapper = entity_metadata_wrapper('og_entity_test', $entity);
    $wrapper->{OG_GROUP_FIELD}->set(1);
    $wrapper->save();

    // Associate user to the group, and grant "admin" role.
    $user2 = $this->backdropCreateUser();
    $values = array('entity_type' => 'user', 'entity' => $user2);
    og_group('og_entity_test', $entity->pid, $values);
    $og_roles = og_roles('og_entity_test', 'main');

    $rid = array_search(OG_ADMINISTRATOR_ROLE, $og_roles);
    og_role_grant('og_entity_test', $entity->pid, $user2->uid, $rid);

    // Active member.
    $roles = og_get_user_roles('og_entity_test', $entity->pid, $user2->uid);
    $expected_result = array(
      array_search(OG_AUTHENTICATED_ROLE, $og_roles) => OG_AUTHENTICATED_ROLE,
      array_search(OG_ADMINISTRATOR_ROLE, $og_roles) => OG_ADMINISTRATOR_ROLE,
    );
    $this->assertEqual($roles, $expected_result, 'Active member has also the admin role.');
    $this->assertTrue(og_user_access('og_entity_test', $entity->pid, 'update group', $user2), 'Active member has access.');

    // Pending member.
    $values['state'] = OG_STATE_PENDING;
    og_group('og_entity_test', $entity->pid, $values);
    $roles = og_get_user_roles('og_entity_test', $entity->pid, $user2->uid);
    $rid = array_search(OG_ANONYMOUS_ROLE, $og_roles);
    $expected_result = array($rid => OG_ANONYMOUS_ROLE);
    $this->assertEqual($roles, $expected_result, 'Pending member has non-member role.');
    $this->assertFalse(og_user_access('og_entity_test', $entity->pid, 'update group', $user2), 'Pending member has no access.');

    // Blocked member.
    $values['state'] = OG_STATE_BLOCKED;
    og_group('og_entity_test', $entity->pid, $values);
    $roles = og_get_user_roles('og_entity_test', $entity->pid, $user2->uid);
    $this->assertEqual($roles,  array(), 'Blocked member has no roles.');
    $this->assertFalse(og_user_access('og_entity_test', $entity->pid, 'update group', $user2), 'Blocked member has no access.');
  }

  function testGrantRolesTwiceForPendingUsers() {
    // Create user.
    $user1 = $this->backdropCreateUser();

    // Create an entity.
    $entity = entity_create('og_entity_test', array('name' => 'main', 'uid' => $user1->uid));
    $wrapper = entity_metadata_wrapper('og_entity_test', $entity);
    $wrapper->{OG_GROUP_FIELD}->set(1);
    $wrapper->save();

    $og_roles = og_roles('og_entity_test', 'main');

    //Add the user to the group.
    $values = array('entity_type' => 'user', 'entity' => $user1, 'state' => OG_STATE_PENDING);
    $rid = array_search(OG_ADMINISTRATOR_ROLE, $og_roles);
    og_group('og_entity_test', $entity->pid, $values);

    // Try granting the admin role to a pending user twice.
    og_role_grant('og_entity_test', $entity->pid, $user1->uid, $rid);
    og_role_grant('og_entity_test', $entity->pid, $user1->uid, $rid);
    $this->pass('Granting a role twice should not throw an exception.');
  }
}

class OgDefaultAccessFieldTestCase extends OgTestBase {

  function setUp($modules = array()) {
    parent::setUp($modules);
  }


  /**
   * Test groups with default access field enabled or disabled.
   */
  function testOgDefaultAccessField() {
    // Create user.
    $user1 = $this->backdropCreateUser();

    // Add OG group field to the og_entity_test's "main" bundle.
    og_create_field(OG_GROUP_FIELD, 'og_entity_test', 'main');

    $og_roles = og_roles('og_entity_test', 'main');

    // Group without default access field.
    $entity = entity_create('og_entity_test', array('name' => 'main', 'uid' => $user1->uid));
    $wrapper = entity_metadata_wrapper('og_entity_test', $entity);
    $wrapper->{OG_GROUP_FIELD}->set(1);
    $wrapper->save();
    $this->assertEqual($og_roles, og_roles('og_entity_test', 'main', $entity->pid), t('Group without default access field is assigned to the global roles and permissions settings.'));

    // Add default access field to the og_entity_test's "main" bundle.
    og_create_field(OG_DEFAULT_ACCESS_FIELD, 'og_entity_test', 'main');

    // Group with default access field disabled.
    $entity = entity_create('og_entity_test', array('name' => 'main', 'uid' => $user1->uid));
    $wrapper = entity_metadata_wrapper('og_entity_test', $entity);
    $wrapper->{OG_GROUP_FIELD}->set(1);
    $wrapper->{OG_DEFAULT_ACCESS_FIELD}->set(0);
    $wrapper->save();
    $this->assertEqual($og_roles, og_roles('og_entity_test', 'main', $entity->pid), t('Group with default access field disabled is assigned to the global roles and permissions settings.'));

    // Add admin role to a user.
    $rid = array_search(OG_ADMINISTRATOR_ROLE, $og_roles);
    og_role_grant('og_entity_test', $entity->pid, $user1->uid, $rid);
    $user_roles = og_get_user_roles('og_entity_test', $entity->pid, $user1->uid);
    $this->assertTrue(array_search(OG_ADMINISTRATOR_ROLE, $user_roles), t('User has default "admin" role.'));

    // Group with default access field enabled.
    $wrapper->{OG_DEFAULT_ACCESS_FIELD}->set(1);
    $wrapper->save();
    $new_og_roles = og_roles('og_entity_test', 'main', $entity->pid);
    $this->assertNotEqual($og_roles, $new_og_roles, t('Group with default access field enabled has own roles and permissions settings.'));

    // Assert the newley created admin role was mapped to the default one.
    $user_roles = og_get_user_roles('og_entity_test', $entity->pid, $user1->uid, FALSE);
    $this->assertTrue(array_search(OG_ADMINISTRATOR_ROLE, $user_roles), t('User has overriden "admin" role.'));

    // Disable existing group's default access field.
    config_set('og.settings', 'og_maintain_overridden_roles', TRUE);
    $wrapper->{OG_DEFAULT_ACCESS_FIELD}->set(0);
    $wrapper->save();
    $this->assertEqual($og_roles, og_roles('og_entity_test', 'main', $entity->pid), t('Group with enabled default access field that was disabled is assigned to the global roles and permissions settings.'));

    // Assert admin role was maintained from the overriden group.
    $user_roles = og_get_user_roles('og_entity_test', $entity->pid, $user1->uid, FALSE);
    $this->assertTrue(array_search(OG_ADMINISTRATOR_ROLE, $user_roles), t('"admin" role maintained from overriden group.'));

    // Override group.
    $wrapper->{OG_DEFAULT_ACCESS_FIELD}->set(1);
    $wrapper->save();

    // Assert admin role was not maintained from the overriden group.
    config_set('og.settings', 'og_maintain_overridden_roles', FALSE);
    $wrapper->{OG_DEFAULT_ACCESS_FIELD}->set(0);
    $wrapper->save();

    $user_roles = og_get_user_roles('og_entity_test', $entity->pid, $user1->uid, FALSE);
    $this->assertFalse(array_search(OG_ADMINISTRATOR_ROLE, $user_roles), t('"admin" role not maintained from overriden group.'));
  }
}

/**
 * Test the complex widget.
 */
class OgFieldWidgetTestCase extends OgTestBase {

  function setUp($modules = array()) {
    parent::setUp($modules);

    // Add OG group field to a the node's "group" bundle.
    $this->backdropCreateContentType(array('type' => 'group'));
    og_create_field(OG_GROUP_FIELD, 'node', 'group');

    // Add OG audience field to the node's "post" bundle.
    $this->backdropCreateContentType(array('type' => 'post'));
    $og_field = og_fields_info(OG_AUDIENCE_FIELD);
    $og_field['instance']['required'] = TRUE;
    og_create_field(OG_AUDIENCE_FIELD, 'node', 'post', $og_field);
  }

  /**
   * Test "field modes" of the OG reference widget.
   */
  function testFieldModes() {
    $user1 = $this->backdropCreateUser(array('administer group', 'access content', 'create post content'));
    $user2 = $this->backdropCreateUser(array('access content', 'create post content'));

    // Create group nodes.
    $settings = array(
      'type' => 'group',
      OG_GROUP_FIELD . '[und][0][value]' => 1,
    );
    $settings['uid'] = $user1->uid;
    $group1 = $this->backdropCreateNode($settings);

    $settings['uid'] = $user2->uid;
    $group2 = $this->backdropCreateNode($settings);

    $settings = array(
      'type' => 'post',
    );
    $settings['uid'] = $user1->uid;
    $post1 = $this->backdropCreateNode($settings);
    og_group('node', $group1->nid, array('entity_type' => 'node', 'entity' => $post1));

    $settings['uid'] = $user2->uid;
    $post2 = $this->backdropCreateNode($settings);
    og_group('node', $group2->nid, array('entity_type' => 'node', 'entity' => $post2));

    $this->backdropLogin($user1);
    $this->backdropGet("node/$post1->nid/edit");

    $fields = $this->xpath('//*[@id="edit-og-group-ref-und-0-default"]');
    $this->assertEqual($fields[0]->option['value'], '_none', '"Default" field mode is not required for administrator.');

    $fields = $this->xpath('//*[@id="edit-og-group-ref-und-0-admin-0-target-id"]');
    $this->assertTrue(strpos($fields[0]->attributes()->class[0], 'form-autocomplete'), '"Administrator field more is an autocomplete widget type."');

    $this->backdropLogin($user2);
    $this->backdropGet("node/$post2->nid/edit");

    $fields = $this->xpath('//*[@id="edit-og-group-ref-und-0-default"]');
    $this->assertEqual($fields[0]->option['value'], $group2->nid, '"Default" field mode is required.');
  }

  /**
   * Test "field widget settings" of the OG reference widget.
   */
  function testFieldSettings() {
    $user = $this->backdropCreateUser(array('administer content types', 'administer group', 'access content', 'administer fields'));
    $this->backdropLogin($user);

    $widgets = field_info_widget_types();
    foreach($widgets as $widget => $settings){
      if(in_array('entityreference', $settings['field types'])){
        $widget_type_url = "admin/structure/types/manage/post/fields/".OG_AUDIENCE_FIELD."/widget-type";
        $this->backdropPost($widget_type_url, array('widget_type' => $widget), 'Continue');
        $edit_url = "admin/structure/types/manage/post/fields/".OG_AUDIENCE_FIELD;
        $this->backdropPost($edit_url, array(), 'Save settings');
      }
    }
  }

  /**
   * Test non-accessible group IDs are saved, upon form submit.
   */
  function testHiddenGroupIds() {
    $user1 = $this->backdropCreateUser(array('administer group', 'access content', 'create post content'));
    $user2 = $this->backdropCreateUser(array('access content', 'create post content'));

    // Create group nodes.
    $settings = array(
      'type' => 'group',
      OG_GROUP_FIELD . '[und][0][value]' => 1,
    );
    $settings['uid'] = $user1->uid;
    $group1 = $this->backdropCreateNode($settings);

    $settings['uid'] = $user2->uid;
    $group2 = $this->backdropCreateNode($settings);

    $settings = array(
      'type' => 'post',
    );
    $settings['uid'] = $user1->uid;
    $post1 = $this->backdropCreateNode($settings);
    og_group('node', $group1->nid, array('entity_type' => 'node', 'entity' => $post1));
    og_group('node', $group2->nid, array('entity_type' => 'node', 'entity' => $post1));

    $this->backdropLogin($user2);
    $this->backdropPost("node/$post1->nid/edit", array(), 'Save');

    // Assert post still belongs to both groups, although user was able
    // to select only one.
    $gids = og_get_entity_groups('node', $post1);
    $this->assertEqual(count($gids['node']), 2, 'Hidden groups remained.');
  }

  /**
   * Test a non "administer group" user with pending membership, re-saving
   * user edit.
   */
  function testUserEdit() {
    $user1 = $this->backdropCreateUser();
    $user2 = $this->backdropCreateUser();

    $settings = array(
      'type' => 'group',
      OG_GROUP_FIELD . '[und][0][value]' => 1,
    );
    $settings['uid'] = $user1->uid;
    $group1 = $this->backdropCreateNode($settings);

    og_group('node', $group1->nid, array('entity' => $user2, 'state' => OG_STATE_PENDING));

    $this->backdropLogin($user2);
    $this->backdropPost("user/$user2->uid/edit", array(), 'Save');

    $this->assertTrue(og_get_entity_groups('user', $user2, array(OG_STATE_PENDING)), 'User membership was retained after user save.');
  }

  /**
   * Test multiple group-audience fields.
   */
  function testMultipleFields() {
    // Add another group-audience field.
    $og_field = og_fields_info(OG_AUDIENCE_FIELD);
    og_create_field('another_field', 'node', 'post', $og_field);

    $user1 = $this->backdropCreateUser();

    // Create a group.
    $settings = array(
      'type' => 'group',
      OG_GROUP_FIELD . '[und][0][value]' => 1,
      'uid' => $user1->uid,
    );
    $group1 = $this->backdropCreateNode($settings);
    $group2 = $this->backdropCreateNode($settings);

    // Create group content.
    $settings = array(
      'type' => 'post',
      'uid' => $user1->uid,
    );
    $post1 = $this->backdropCreateNode($settings);

    og_group('node', $group1->nid, array('entity_type' => 'node', 'entity' => $post1, 'field_name' => OG_AUDIENCE_FIELD));
    og_group('node', $group2->nid, array('entity_type' => 'node', 'entity' => $post1, 'field_name' => 'another_field'));

    $this->backdropLogin($user1);
    $this->backdropGet("node/$post1->nid/edit");

    // Assert correct selection in both fields.
    $this->assertOptionSelected('edit-og-group-ref-und-0-default', $group1->nid);
    $this->assertOptionSelected('edit-another-field-und-0-default', $group2->nid);
  }
}

/**
 * Test the revocation of group roles.
 */
class OgRoleRevoke extends OgTestBase {

  function setUp($modules = array()) {
    parent::setUp($modules);
  }

  function testOgRoleRevoke()  {
    // Create a user.
    $user1 = $this->backdropCreateUser();

    // Add OG group field to the og_entity_test's "main" bundle.
    og_create_field(OG_GROUP_FIELD, 'og_entity_test', 'main');

    // Create two groups entity1 and entity2.
    $entity1 = entity_create('og_entity_test', array('name' => 'main', 'uid' => $user1->uid));
    $wrapper = entity_metadata_wrapper('og_entity_test', $entity1);
    $wrapper->{OG_GROUP_FIELD}->set(1);
    $wrapper->save();

    $entity2 = entity_create('og_entity_test', array('name' => 'main', 'uid' => $user1->uid));
    $wrapper = entity_metadata_wrapper('og_entity_test', $entity2);
    $wrapper->{OG_GROUP_FIELD}->set(1);
    $wrapper->save();

    // Create a role named 'role1'.
    $role1 = og_role_create('role1', 'og_entity_test', 0, 'main');
    og_role_save($role1);

    // Create a role named 'role2'.
    $role2 = og_role_create('role2', 'og_entity_test', 0, 'main');
    og_role_save($role2);

    // Grant 'role1' to user1 at entity1 and 'role2' to user1 at entity2
    og_role_grant('og_entity_test', $entity1->pid, $user1->uid, $role1->rid);
    og_role_grant('og_entity_test', $entity2->pid, $user1->uid, $role2->rid);

    // Unsubscribe user1 from entity1.
    og_ungroup('og_entity_test', $entity1->pid, 'user', $user1->uid);

    $this->assertFalse(og_get_user_roles('og_entity_test', $entity1->pid, $user1->uid, FALSE), t('User is unsubscribed from group, so role was revoked'));
    $this->assertTrue(og_get_user_roles('og_entity_test', $entity2->pid, $user1->uid, FALSE), t('User is still subscribed to group, so return value is not empty'));

    $uid = $user1->uid;
    // Delete user1.
    user_delete($user1->uid);

    $result = db_query('SELECT * FROM {og_users_roles} WHERE uid = :uid', array(':uid' => $uid));
    $this->assertFalse($result->rowCount(), t('User is removed, so all roles of this user were revoked'));
  }
}

/**
 * Test queying group-audience fields using entityFieldQuery.
 */
class OgEntityFieldQueryTestCase extends OgTestBase {

  function setUp($modules = array()) {
    parent::setUp($modules);

    $user1 = $this->backdropCreateUser();
    $user2 = $this->backdropCreateUser();
    $type = $this->backdropCreateContentType();
    $group_type = $type->type;

    $type = $this->backdropCreateContentType();
    $group_content_type = $type->type;

    og_create_field(OG_GROUP_FIELD, 'node', $group_type);
    og_create_field(OG_GROUP_FIELD, 'og_entity_test', 'main');

    // Add audience field to reference node.
    $og_field = og_fields_info(OG_AUDIENCE_FIELD);
    og_create_field('og_node', 'node', $group_content_type, $og_field);

    $og_entity_test = entity_create('og_entity_test', array('name' => 'test', 'uid' => $user1->uid));
    $og_entity_test->save();
    og_create_field('og_node', 'og_entity_test', 'test', $og_field);

    // Add audience field to reference entity-test.
    $og_field['field']['settings']['target_type'] = 'og_entity_test';
    og_create_field('og_og_entity_test', 'node', $group_content_type, $og_field);
    og_create_field('og_og_entity_test', 'user', 'user', $og_field);

    // Create a non-group audience, entity reference field.
    $field = array(
      'entity_types' => array('node'),
      'settings' => array(
        'handler' => 'base',
        'target_type' => 'node',
        'handler_settings' => array(
          'target_bundles' => array(),
        ),
      ),
      'field_name' => 'node_reference',
      'type' => 'entityreference',
      'cardinality' => 1,
    );
    $field = field_create_field($field);
    $instance = array(
      'field_name' => 'node_reference',
      'bundle' => $group_content_type,
      'entity_type' => 'node',
    );
    field_create_instance($instance);

    // Create two groups.
    $group1 = entity_create('og_entity_test', array('name' => 'main', 'uid' => $user1->uid));
    $wrapper = entity_metadata_wrapper('og_entity_test', $group1);
    $wrapper->{OG_GROUP_FIELD}->set(1);
    $wrapper->save();

    $settings = array(
      'type' => $group_type,
      'uid' => $user1->uid,
    );
    $settings[OG_GROUP_FIELD][LANGUAGE_NONE][0]['value'] = 1;
    $group2 = $this->backdropCreateNode($settings);

    // Create group-content.
    $settings = array(
      'type' => $group_content_type,
      'uid' => $user1->uid,
    );
    $node = $this->backdropCreateNode($settings);

    $wrapper = entity_metadata_wrapper('node', $node);
    $wrapper->node_reference->set($group2);
    $wrapper->save();
    // Prevent stale field data.
    $node = node_load($node->nid);

    $values = array(
      'entity_type' => 'node',
      'entity' => $node,
    );

    og_group('og_entity_test', $group1, $values);
    og_group('node', $group2, $values);

    $values = array(
      'entity_type' => 'og_entity_test',
      'entity' => $og_entity_test,
    );
    og_group('node', $group2, $values);

    $values = array(
      'entity_type' => 'user',
      'entity' => $user2,
    );
    og_group('node', $group2, $values);

    $this->group1 = $group1;
    $this->group2 = $group2;
    $this->node = $node;
    $this->user1 = $user1;
    $this->user2 = $user2;
    $this->og_entity_test = $og_entity_test;
  }

  /**
   * Test the following query scenarios:
   *
   * - Single group audience.
   * - Multiple group audience.
   * - Single group audience first, with another non-audience field.
   * - Non-audience field first, with single group audience.
   * - Multiple entity types in entityCondition().
   * - No entity property.
   * - Non-node entity without revision table (e.g. og_entity_test).
   * - Non-node entity without revision table and without bundles (e.g. user).
   * - Count query.
   */
  function testEntityFieldQuery()  {
    $group1 = $this->group1;
    $group2 = $this->group2;
    $node = $this->node;
    $user1 = $this->user1;
    $og_entity_test = $this->og_entity_test;

    // Single group audience.
    $query = new EntityFieldQuery();
    $result = $query
      ->entityCondition('entity_type', 'node')
      ->propertyCondition('type', $node->type)
      ->fieldCondition('og_node', 'target_id', $group2->nid)
      ->execute();

    $this->assertEqual(array_keys($result['node']), array($node->nid), 'Single group audience query is correct.');

    // TODO: the following lines were from the original test. They are commented
    // out because of a bug in OG's og_query_og_membership_alter. See 
    // https://www.drupal.org/project/og/issues/2039903
    // Let's keep an eye on that D7 issue and reactivate this test when
    // that's solved.

    // Multiple group audience.
    // $query = new EntityFieldQuery();
    // $result = $query
    //   ->entityCondition('entity_type', 'node')
    //   ->propertyCondition('type', $node->type)
    //   ->fieldCondition('og_node', 'target_id', $group2->nid)
    //   ->fieldCondition('og_og_entity_test', 'target_id', $group1->pid)
    //   ->execute();

    // In the meantime, we provide an alternative way to test this
    // following the recommendation posted here:
    // https://www.drupal.org/project/og/issues/2039903#comment-10010179

    // Multiple group audience.
    $query = new EntityFieldQuery();
    $result1 = $query
      ->entityCondition('entity_type', 'node')
      ->propertyCondition('type', $node->type)
      ->fieldCondition('og_node', 'target_id', $group2->nid)
      ->execute();

    $query = new EntityFieldQuery();
    $result2 = $query
      ->entityCondition('entity_type', 'node')
      ->propertyCondition('type', $node->type)
      ->fieldCondition('og_og_entity_test', 'target_id', $group1->pid)
      ->execute();

    $result_ids = array_intersect(array_keys($result1['node']), array_keys($result2['node']));
    $this->assertEqual($result_ids, array($node->nid), 'Multiple group audience query is correct.');

    // Single group audience first, with another non-audience field.
    $query = new EntityFieldQuery();
    $result = $query
      ->entityCondition('entity_type', 'node')
      ->propertyCondition('type', $node->type)
      ->fieldCondition('og_node', 'target_id', $group2->nid)
      ->fieldCondition('node_reference', 'target_id', $group2->nid)
      ->execute();

    $this->assertEqual(array_keys($result['node']), array($node->nid), 'Single group audience first, with another non-audience field query is correct.');

    // Non-audience field first, with single group audience.
    $query = new EntityFieldQuery();
    $result = $query
      ->entityCondition('entity_type', 'node')
      ->propertyCondition('type', $node->type)
      ->fieldCondition('node_reference', 'target_id', $group2->nid)
      ->fieldCondition('og_node', 'target_id', $group2->nid)
      ->execute();

    $this->assertEqual(array_keys($result['node']), array($node->nid), 'Non-audience field first, with single group audience query is correct.');

    // Multiple entity types in entityCondition().
    $query = new EntityFieldQuery();
    $result = $query
      ->entityCondition('entity_type', array('node', 'user'), 'IN')
      ->fieldCondition('node_reference', 'target_id', $group2->nid)
      ->fieldCondition('og_node', 'target_id', $group2->nid)
      ->execute();

    $this->assertEqual(array_keys($result['node']), array($node->nid), 'Multiple entity types in entityCondition() query is correct.');

    // No entity property.
    $query = new EntityFieldQuery();
    $result = $query
      ->entityCondition('entity_type', 'node')
      ->fieldCondition('og_node', 'target_id', $group2->nid)
      ->execute();

    $this->assertEqual(array_keys($result['node']), array($node->nid), 'No entity property query is correct.');

    // Non-node entity without revision table.
    $query = new EntityFieldQuery();
    $result = $query
      ->entityCondition('entity_type', 'og_entity_test')
      ->fieldCondition('og_node', 'target_id', $group2->nid)
      ->execute();

    $this->assertEqual(array_keys($result['og_entity_test']), array($og_entity_test->pid), 'Non-node entity without revision table query is correct.');

    // Non-node entity without revision table and without bundles.
    $query = new EntityFieldQuery();
    $result = $query
      ->entityCondition('entity_type', 'user')
      ->fieldCondition('og_og_entity_test', 'target_id', $group2->nid)
      ->execute();

    $expected_values = array(
      $this->user1->uid,
      $this->user2->uid,
    );
    $this->assertEqual(array_keys($result['user']), $expected_values, 'Non-node entity without revision table and without bundles query is correct.');

    // Count query.
    $query = new EntityFieldQuery();
    $result = $query
      ->entityCondition('entity_type', 'node')
      ->propertyCondition('type', $node->type)
      ->fieldCondition('og_node', 'target_id', $group2->nid)
      ->count()
      ->execute();

    $this->assertEqual($result, 1, 'Count query is correct.');
  }
}


/**
 * EntityFieldQuery FieldConditions with multiple group content entity types.
 */
class OgEntityFieldQueryFieldConditionTestCase extends OgTestBase {

  function setUp($modules = array()) {
    parent::setUp($modules);

    $user1 = $this->backdropCreateUser();
    $user2 = $this->backdropCreateUser();
    $type = $this->backdropCreateContentType();
    $this->group_type = $type->type;

    $type = $this->backdropCreateContentType();
    $this->group_content_type = $type->type;

    og_create_field(OG_GROUP_FIELD, 'node', $this->group_type);

    // Add audience field to group content node type.
    $og_field = og_fields_info(OG_AUDIENCE_FIELD);
    og_create_field(OG_AUDIENCE_FIELD, 'node', $this->group_content_type, $og_field);

    // Create a simple text list field.
    $field = array(
      'entity_types' => array('node'),
      'settings' => array(
        'allowed_values' => array(
          'red' => 'red',
          'blue' => 'blue',
        ),
      ),
      'field_name' => 'list_text',
      'type' => 'list_text',
      'cardinality' => 1,
    );
    $field = field_create_field($field);
    $instance = array(
      'field_name' => 'list_text',
      'bundle' => $this->group_content_type,
      'entity_type' => 'node',
    );
    field_create_instance($instance);

    // Create groups.
    $settings = array(
      'type' => $this->group_type,
      'uid' => $user1->uid,
    );
    $settings[OG_GROUP_FIELD][LANGUAGE_NONE][0]['value'] = 1;
    $group1 = $this->backdropCreateNode($settings);

    $settings = array(
      'type' => $this->group_type,
      'uid' => $user1->uid,
    );
    $settings[OG_GROUP_FIELD][LANGUAGE_NONE][0]['value'] = 1;
    $group2 = $this->backdropCreateNode($settings);

    // Create group-content.
    // First content node.
    $settings = array(
      'type' => $this->group_content_type,
      'uid' => $user1->uid,
    );
    $settings['list_text'][LANGUAGE_NONE][0]['value'] = 'red';

    $node = $this->backdropCreateNode($settings);

    $values = array(
      'entity_type' => 'node',
      'entity' => $node,
    );
    og_group('node', $group1, $values);

    // Second content node.
    $settings = array(
      'type' => $this->group_content_type,
      'uid' => $user1->uid,
    );
    $settings['list_text'][LANGUAGE_NONE][0]['value'] = 'red';

    $node = $this->backdropCreateNode($settings);

    $values = array(
      'entity_type' => 'node',
      'entity' => $node,
    );
    og_group('node', $group2, $values);

    // Entity test content.
    // We need to create enough test entities so that we get some whose IDs are
    // the same as the group content nodes.
    $content = array();
    foreach (range(1, 5) as $i) {
      $og_entity_test = entity_create('og_entity_test', array(
        // Weirdly, 'name' is the bundle key.
        'name' => 'main',
        'uid' => $user1->uid,
      ));
      $og_entity_test->save();
      $content[] = $og_entity_test;
    }

    // Add audience field to group content test entity type.
    $og_field = og_fields_info(OG_AUDIENCE_FIELD);
    og_create_field(OG_AUDIENCE_FIELD, 'og_entity_test', 'main', $og_field);
    foreach ($content as $i => $og_entity_test) {
      $values = array(
        'entity_type' => 'og_entity_test',
        'entity' => $og_entity_test,
      );
      og_group('node', $group1, $values);
    }

    $this->group1 = $group1;
    $this->group2 = $group2;
  }

  function testEntityFieldQueryFieldConditions() {
    // Query for all nodes with a field value of 'red'.
    $query = new EntityFieldQuery();
    $query->entityCondition('entity_type', 'node');
    $query->entityCondition('bundle', $this->group_content_type);
    $query->fieldCondition('list_text', 'value', 'red');
    $result = $query->execute();

    $this->assertEqual(count($result['node']), 2, "The correct number of nodes was returned for the query with only the plain field.");

    // Query for group content nodes.
    $query = new EntityFieldQuery();
    $query->entityCondition('entity_type', 'node');
    $query->entityCondition('bundle', $this->group_content_type);
    $query->fieldCondition(OG_AUDIENCE_FIELD, 'target_id', $this->group1->nid);
    $result = $query->execute();

    $this->assertEqual(count($result['node']), 1, "The correct number of nodes was returned for the query with only the OG field condition.");

    // Query for nodes in group 1 with a field value of 'red'.
    $query = new EntityFieldQuery();
    $query->entityCondition('entity_type', 'node');
    $query->entityCondition('bundle', $this->group_content_type);
    $query->fieldCondition(OG_AUDIENCE_FIELD, 'target_id', $this->group1->nid);
    $query->fieldCondition('list_text', 'value', 'red');
    $result = $query->execute();

    $this->assertEqual(count($result['node']), 1, "The correct number of nodes was returned for the query with the OG field condition first.");

    // Query for nodes in group 1 with a field value of 'red', but this time
    // with the field conditions the other way round.
    $query = new EntityFieldQuery();
    $query->entityCondition('entity_type', 'node');
    $query->entityCondition('bundle', $this->group_content_type);
    $query->fieldCondition('list_text', 'value', 'red');
    $query->fieldCondition(OG_AUDIENCE_FIELD, 'target_id', $this->group1->nid);
    $result = $query->execute();

    $this->assertEqual(count($result['node']), 1, "The correct number of nodes was returned for the query with the OG field condition second.");
  }

}

/**
 * Test group-audience field auto-create.
 */
class OgAudienceFieldAutoCreateTestCase extends OgTestBase {

  function setUp($modules = array()) {
    parent::setUp($modules);
  }

  /**
   * Test auto-attaching group-audience fields to the user entity.
   */
  function testAutoAttach()  {
    $type1 = $this->backdropCreateContentType();
    $type2 = $this->backdropCreateContentType();

    $this->assertFalse(field_info_instance('user', 'og_user_node', 'user'), 'Field does not exist in user entity yet.');
    og_create_field(OG_GROUP_FIELD, 'node', $type1->type);
    $this->assertTrue(field_info_instance('user', 'og_user_node', 'user'), 'Field was added to the user entity.');

    // Change field to reference only type1.
    $field = field_info_field('og_user_node');
    $field['settings']['handler_settings']['target_bundles'] = array($type1->type);
    field_update_field($field);

    // Assert an alternative field name was found.
    $this->assertFalse(field_info_instance('user', 'og_user_node1', 'user'), 'Alternative field does not exist in user entity yet.');
    og_create_field(OG_GROUP_FIELD, 'node', $type2->type);
    $this->assertTrue(field_info_instance('user', 'og_user_node1', 'user'), 'Alternative field was added to the user entity.');
  }
}

class OgBehaviorHandlerTestCase extends OgTestBase {

  function setUp($modules = array()) {
    $modules[] = 'og_test';
    parent::setUp($modules);

    // Add OG group field to the og_entity_test's "main" bundle.
    og_create_field(OG_GROUP_FIELD, 'og_entity_test', 'main');

    $type = $this->backdropCreateContentType(array('type' => 'behavior'));
    $this->group_content = $type->type;

    // Add OG audience field to the new bundle.
    $og_field = og_fields_info(OG_AUDIENCE_FIELD);
    $og_field['field']['settings']['target_type'] = 'og_entity_test';
    og_create_field(OG_AUDIENCE_FIELD, 'node', $type->type, $og_field);
  }

  /**
   * Test piping group association via the group-audience field.
   */
  function testGroupAudienceField() {
    $user1 = $this->backdropCreateUser();
    $user2 = $this->backdropCreateUser();

    $entity1 = entity_create('og_entity_test', array('name' => 'main', 'uid' => $user1->uid));
    $wrapper = entity_metadata_wrapper('og_entity_test', $entity1);
    $wrapper->{OG_GROUP_FIELD}->set(1);
    $wrapper->save();

    $settings = array();
    $settings['type'] = $this->group_content;
    $settings['uid'] = $user2->uid;
    $node = $this->backdropCreateNode($settings);

    $wrapper = entity_metadata_wrapper('node', $node);

    $this->assertFalse(og_is_member('og_entity_test', $entity1->pid, 'node', $node), t('Node is not assigned to group1.'));
    $wrapper->{OG_AUDIENCE_FIELD}[] = $entity1->pid;
    $wrapper->save();
    $og_membership = og_get_membership('og_entity_test', $entity1->pid, 'node', $node->nid);
    $id = $og_membership->id;
    $this->assertTrue(og_is_member('og_entity_test', $entity1->pid, 'node', $node), t('Node is assigned to group1 with active state.'));

    $wrapper->{OG_AUDIENCE_FIELD}->set(NULL);
    $wrapper->save();
    $this->assertFalse(og_get_entity_groups('node', $node), t('Node is not associated with any group.'));
  }

  /**
   * Test skipping OgBehaviorHandler.
   */
  function testGroupAudienceFieldSkipBehavior() {
    $user1 = $this->backdropCreateUser();
    $user2 = $this->backdropCreateUser();

    $entity1 = entity_create('og_entity_test', array('name' => 'main', 'uid' => $user1->uid));
    $wrapper = entity_metadata_wrapper('og_entity_test', $entity1);
    $wrapper->{OG_GROUP_FIELD}->set(1);
    $wrapper->save();

    $settings = array();
    $settings['type'] = $this->group_content;
    $settings['uid'] = $user2->uid;
    $node = $this->backdropCreateNode($settings);

    og_group('og_entity_test', $entity1, array('entity_type' => 'node', 'entity' => $node));
    $node->og_group_on_save = array('group_type' => 'og_entity_test', 'gid' => $entity1->pid);
    node_save($node);

    $this->assertFalse(og_get_entity_groups('node', $node), 'Widget behavior removed group association as expected.');

    $node = node_load($node->nid);
    $node->og_group_on_save = array('group_type' => 'og_entity_test', 'gid' => $entity1->pid);
    $node->skip_og_membership = TRUE;
    node_save($node);

    $gids = og_get_entity_groups('node', $node);
    $this->assertEqual(array_values($gids['og_entity_test']), array($entity1->pid), 'Widget behavior was skipped and removed group association as expected.');
  }

  /**
   * Test settings the OG membership state via field values, when associating
   * a new group-content to a group.
   */
  function testSetStateOnInsert() {
    $permissions = array(
      'access content',
      "create $this->group_content content",
      'administer group',
    );
    $user1 = $this->backdropCreateUser();
    $user2 = $this->backdropCreateUser($permissions);
    $user3 = $this->backdropCreateUser($permissions);

    // Save the 'main' entity type to allow entityreference to 
    // access the field in the 'og_entity_test' entity.
    $this->og_entity_types['main']->save();

    // Create a group.
    $entity1 = entity_create('og_entity_test', array('name' => 'main', 'uid' => $user1->uid));
    $wrapper = entity_metadata_wrapper('og_entity_test', $entity1);
    $wrapper->{OG_GROUP_FIELD}->set(1);
    $wrapper->save();

    og_group('og_entity_test', $entity1, array('entity_type' => 'user', 'entity' => $user2));
    og_group('og_entity_test', $entity1, array('entity_type' => 'user', 'entity' => $user3));

    // Post a node, state should be active.
    $type = str_replace('_', '-', $this->group_content);
    $edit = array(
      'title' => 'state-active',
      'og_group_ref[und][0][default][]' => array($entity1->pid),
    );

    $this->backdropLogin($user2);
    $this->backdropPost('node/add/' . $type, $edit, t('Save'));
    // Get the nid of the node just saved.
    $query = new EntityFieldQuery();
    $result = $query->entityCondition('entity_type', 'node')
          ->propertyCondition('title', 'state-active')
          ->execute();
    $nid1 = key($result['node']);
    $gids = og_get_entity_groups('node', $nid1);
    $id = key($gids['og_entity_test']);
    $og_membership = og_membership_load($id);
    $this->assertEqual($og_membership->state, OG_STATE_ACTIVE, 'Membership status is Active');

    // Post a node, state should be pending.
    $this->backdropLogin($user3);
    $edit['title'] = 'state-pending';
    $this->backdropPost('node/add/' . $type, $edit, t('Save'));
    // Get the nid of the node just saved.
    $query = new EntityFieldQuery();
    $result = $query->entityCondition('entity_type', 'node')
          ->propertyCondition('title', 'state-pending')
          ->execute();
    $nid2 = key($result['node']);
    $gids = og_get_entity_groups('node', $nid2, array(OG_STATE_PENDING));
    $id = key($gids['og_entity_test']);
    $og_membership = og_membership_load($id);
    $this->assertEqual($og_membership->state, OG_STATE_PENDING, 'Memebership status is Active');
  }
}

/**
 * Testing for deleting orphans group content.
 */
class OgDeleteOrphansTestCase extends OgTestBase {

  public $group_type;
  public $node_type;

  function setUp($modules = array()) {
    $modules[] = 'og_test';
    parent::setUp($modules);

    // Create a group content type.
    $group = $this->backdropCreateContentType();
    og_create_field(OG_GROUP_FIELD, 'node', $group->type);
    $this->group_type = $group->type;

    // Create group audience content type.
    $type = $this->backdropCreateContentType();
    $this->node_type = $type->type;

    // Add OG audience field to the audience content type.
    $og_field = og_fields_info(OG_AUDIENCE_FIELD);
    $og_field['field']['settings']['target_type'] = 'node';
    og_create_field(OG_AUDIENCE_FIELD, 'node', $type->type, $og_field);

    // Set the setting for delete a group content when deleting group.
    config_set('og.settings', 'og_orphans_delete', TRUE);
    config_set('og.settings', 'og_use_queue', TRUE);
  }

  /**
   * Testing two things:
   *  When deleting a group, the node of the group will be deleted.
   *  Associated node with the deleted group and another group won't be deleted.
   */
  function testDeleteGroup() {
    // Creating two groups.
    $first_group = $this->backdropCreateNode(array('type' => $this->group_type));
    $second_group = $this->backdropCreateNode(array('type' => $this->group_type));

    // Create two nodes.
    $first_node = $this->backdropCreateNode(array('type' => $this->node_type));
    og_group('node', $first_group, array('entity_type' => 'node', 'entity' => $first_node));
    og_group('node', $second_group, array('entity_type' => 'node', 'entity' => $first_node));

    $second_node = $this->backdropCreateNode(array('type' => $this->node_type));
    og_group('node', $first_group, array('entity_type' => 'node', 'entity' => $second_node));

    // Delete the group.
    node_delete($first_group->nid);

    // Execute manually the queue worker.
    $queue = BackdropQueue::get('og_membership_orphans');
    $item = $queue->claimItem();
    og_membership_orphans_worker($item->data);

    // Load the nodes we used during the test.
    $first_node = node_load($first_node->nid);
    $second_node = node_load($second_node->nid);

    // Verify the none orphan node wasn't deleted.
    $this->assertTrue($first_node, "The second node is realted to another group and deleted.");
    // Verify the orphan node deleted.
    $this->assertFalse($second_node, "The orphan node deleted.");
  }

  /**
   * Testing the moving of the node to another group when deleting a group.
   */
  function testMoveOrphans() {
    // Creating two groups.
    $first_group = $this->backdropCreateNode(array('type' => $this->group_type, 'title' => 'move'));
    $second_group = $this->backdropCreateNode(array('type' => $this->group_type));

    // Create a group and relate it to the first group.
    $first_node = $this->backdropCreateNode(array('type' => $this->node_type));
    og_group('node', $first_group, array('entity_type' => 'node', 'entity' => $first_node));

    // Delete the group.
    node_delete($first_group->nid);

    // Execute manually the queue worker.
    $queue = BackdropQueue::get('og_membership_orphans');
    $item = $queue->claimItem();
    og_membership_orphans_worker($item->data);

    // Load the node into a wrapper and verify we moved him to another group.
    $gids = og_get_entity_groups('node', $first_node->nid);
    $gid = reset($gids['node']);

    $this->assertEqual($gid, $second_group->nid, 'The group content moved to another group.');
  }

  /**
   * Tests editing content that belongs to a deleted group.
   *
   * Tests if content belonging to multiple groups can be edited without issues
   * after deleting one of the groups.
   */
  public function testEditGroupContentAfterDeletingGroup() {
    $account = $this->backdropCreateUser(array('edit own ' . $this->node_type . ' content'));
    $this->backdropLogin($account);

    // Create two groups.
    $first_group = $this->backdropCreateNode(array('type' => $this->group_type));
    $second_group = $this->backdropCreateNode(array('type' => $this->group_type));

    // Create group content, assign it to both groups.
    $group_content = $this->backdropCreateNode(array(
      'type' => $this->node_type,
      'title' => 'Lorem ipsum',
      'uid' => $account->uid,
    ));
    og_group('node', $first_group, array('entity_type' => 'node', 'entity' => $group_content));
    og_group('node', $second_group, array('entity_type' => 'node', 'entity' => $group_content));

    // Try to edit the group content node, using the UI.
    $this->backdropPost('node/' . $group_content->nid . '/edit', array(), 'Save');
    $this->assertText($this->node_type . ' Lorem ipsum has been updated.');

    // Delete the first group.
    node_delete($first_group->nid);

    // Try again to edit the group content node.
    $this->backdropPost('node/' . $group_content->nid . '/edit', array(), 'Save');
    $this->assertText($this->node_type . ' Lorem ipsum has been updated.');
  }

  /**
   * Tests calling node_access() on content that belongs to a deleted group.
   *
   * Tests if node_access() can be called for content that has a reference to a
   * no longer existing group when OG is configured to use the delete queue.
   */
  public function testGroupContentNodeAccessAfterDeletingGroupAndWhenUsingQueue() {
    // Configure OG to use queue for deleting pending content.
    config_set('og.settings', 'og_use_queue', TRUE);

    $account = $this->backdropCreateUser(array('access content', 'edit own ' . $this->node_type . ' content'));
    $this->backdropLogin($account);

    // Create two groups.
    $first_group = $this->backdropCreateNode(array('type' => $this->group_type));
    $second_group = $this->backdropCreateNode(array('type' => $this->group_type));

    // Create group content, assign it to both groups.
    $group_content = $this->backdropCreateNode(array(
      'type' => $this->node_type,
      'title' => 'Lorem ipsum',
      'uid' => $account->uid,
    ));
    og_group('node', $first_group, array('entity_type' => 'node', 'entity' => $group_content));
    og_group('node', $second_group, array('entity_type' => 'node', 'entity' => $group_content));

    // Display a list of my nodes, that uses node_access() to check if links may
    // be displayed.
    $this->backdropGet('og_test/my_content');
    $this->assertText('Lorem ipsum');

    // Delete the first group.
    node_delete($first_group->nid);

    // Display a list of my nodes again, to ensure nothing changed.
    $this->backdropGet('og_test/my_content');
    $this->assertNoText('EntityMalformedException');
    $this->assertText('Lorem ipsum');
  }

}

/**
 * Testing publishing content in a group for non members users.
 */
class OgNonMembersPublishingContentTestCase extends OgTestBase {

  public $group;
  public $user;
  public $adminUser;

  public function setUp($modules = array()) {
    $modules[] = 'og_test';
    $modules[] = 'entityreference_prepopulate';
    parent::setUp($modules);

    // Creating a user.
    $this->user = $this->backdropCreateUser();

    // Creating admin.
    $this->adminUser = $this->backdropCreateUser(array('bypass node access', 'administer group'));

    // Create a group content type.
    $this->backdropCreateContentType(array( 'name' => 'Group', 'type' => 'group'));
    og_create_field(OG_GROUP_FIELD, 'node', 'group');

    // Create the group.
    $settings = array(
      'type' => 'group',
      OG_GROUP_FIELD . '[und][0][value]' => 1,
      'uid' => 1,
    );
    $this->group = $this->backdropCreateNode($settings);

    // Create the group content.
    $this->backdropCreateContentType(array('name' => 'Group content', 'type' => 'group_content'));

    // Attach the audience field and enable the prepopulate behavior.
    $og_field = og_fields_info(OG_AUDIENCE_FIELD);
    $og_field['instance']['settings']['behaviors']['prepopulate'] = array(
      'status' => TRUE,
      'action' => 'none',
    );
    og_create_field(OG_AUDIENCE_FIELD, 'node', 'group_content', $og_field);

    // Add permission to the group.
    $og_roles = og_roles('node', 'group');
    $rid = array_search(OG_ANONYMOUS_ROLE, $og_roles);
    og_role_change_permissions($rid, array('create group_content content' => 1));
  }

  /**
   * Testing the option for non members users to publish content in the group
   * when the group identifier passed through the URL.
   */
  public function testNonMembersPublish() {
    // Login as normal user.
    $this->backdropLogin($this->user);

    // Verify the user can't publish content to the group content.
    $this->backdropGet('node/add/group-content');
    $this->assertResponse('403', t('The user can not create post in the group.'));

    // Create a the group content.
    $this->backdropPost('node/add/group-content', array('title' => 'foo'), t('Save'), array('query' => array('og_group_ref' => $this->group->nid)));

    // Verify the node belong to the group.
    $query = new entityFieldQuery();
    $result = $query
      ->entityCondition('entity_type', 'node')
      ->propertyCondition('title', 'foo')
      ->fieldCondition(OG_AUDIENCE_FIELD, 'target_id', $this->group->nid)
      ->execute();

    $this->assertTrue(!empty($result['node']), 'The node was added to the group.');

    $result_node = $result['node'];
    $node_array_keys = array_keys($result_node);
    $nid = reset($node_array_keys);

    $this->backdropLogin($this->adminUser);

    // Verify the audience field will remain after another user editing the
    // group.
    $this->backdroppost('node/' . $nid . '/edit', array(), t('Save'));
    $this->assertText($this->group->title, 'The node is still referenced to the group.');
  }
}

/**
 * Verify that users only with OG permissions can post only inside a group
 *
 */
class OgUserCanPublishGroupContentTypeOnlyInGroup extends OgTestBase {

  public $group;
  public $site_user;
  public $group_user;
  public $group_content;

  public function setUp($modules = array()) {
    parent::setUp($modules);

    // Create a group content type.
    $group = $this->backdropCreateContentType();
    og_create_field(OG_GROUP_FIELD, 'node', $group->type);

    // Create the group.
    $settings = array(
      'type' => $group->type,
      OG_GROUP_FIELD . '[und][0][value]' => 1,
      'uid' => 1,
    );
    $this->group = $this->backdropCreateNode($settings);

    // Create the group content content type.
    $this->group_content = $this->backdropCreateContentType();

    // Attach the audience field.
    og_create_field(OG_AUDIENCE_FIELD, 'node', $this->group_content->type);

    // Add permission to the group.
    $og_roles = og_roles('node', $group->type);
    $rid = array_search(OG_AUTHENTICATED_ROLE, $og_roles);
    og_role_change_permissions($rid, array(
      'create ' . $this->group_content->type . ' content' => 1,
      'update own ' . $this->group_content->type . ' content' => 1,
    ));

    // Creating users.
    $this->group_user = $this->backdropCreateUser();
    $this->site_user = $this->backdropCreateUser(array('create ' . $this->group_content->type . ' content', 'edit own ' . $this->group_content->type . ' content'));

    og_group('node', $this->group->nid, array('entity' => $this->group_user));
  }

  /**
   * Grant to a user the permission to publish a node of a group content and
   * verify that he can't create a node of that content type outside a group.
   */
  public function testGroupUserCanPostGroupContentOnlyInGroup() {
    $node_title = $this->randomName();
    $this->backdropLogin($this->group_user);
    $this->backdropPost('node/add', array('title' => $node_title), t('Save'));
    $this->assertText("You must select one or more groups for this content", "The user can't publish a content outside a group");

    // Check the user can publish node inside the group.
    $edit = array(
      'title' => $node_title,
      'og_group_ref[und][0][default][]' => array($this->group->nid),
    );
    $this->backdropPost('node/add', $edit, t('Save'));

    $this->assertText($this->group_content->type . " " . $node_title . " has been created.", "The user can create content inside a group.");

    // Check the user can edit the node.
    $query = new EntityFieldQuery();
    $result = $query
      ->entityCondition('entity_type', 'node')
      ->propertyCondition('title', $node_title)
      ->fieldCondition(OG_AUDIENCE_FIELD, 'target_id', $this->group->nid)
      ->execute();
    $nids = array_keys($result['node']);
    $node_title = $this->randomName();

    $edit = array(
      'title' => $node_title,
      'og_group_ref[und][0][default][]' => array(),
    );
    $this->backdropPost('node/' . reset($nids) . '/edit', $edit, t('Save'));
    $this->assertText("You must select one or more groups for this content", "The user can't edit a content outside a group");

    $edit = array(
      'title' => $node_title,
      'og_group_ref[und][0][default][]' => array($this->group->nid),
    );
    $this->backdropPost('node/' . reset($nids) . '/edit', $edit, t('Save'));
    $this->assertText($this->group_content->type . " " . $node_title . " has been updated.", "The user can edit content inside a group.");
  }

  /**
   * Verify that non-group user can post group content outside of a group.
   */
  public function testNonGroupUserCanPostGroupContentOutsideGroup() {
    $this->backdropLogin($this->site_user);

    // Set node access strict variable to FALSE for posting outside groups.
    config_set('og.settings', 'og_node_access_strict', FALSE);

    // Verify that the user can publish group content outside a group.
    $node_title = $this->randomName();
    $this->backdropPost('node/add', array('title' => $node_title), t('Save'));

    $params = array(
      '@type' => $this->group_content->type,
      '@title' => $node_title,
    );
    $this->assertText(format_string("@type @title has been created.", $params), "The user can create content outside a group.");

    // Check the user can edit the node.
    $query = new EntityFieldQuery();
    $result = $query
      ->entityCondition('entity_type', 'node')
      ->propertyCondition('title', $node_title)
      ->execute();
    $nids = array_keys($result['node']);

    $node_title = $this->randomName();
    $edit = array(
      'title' => $node_title,
    );
    $this->backdropPost('node/' . reset($nids) . '/edit', $edit, t('Save'));
    $this->assertText($this->group_content->type . " " . $node_title . " has been updated.", "The user can edit content outside a group.");
  }
}

/**
 * Test for publishing content into group the user is not a member.
 */
class OgAutoCompleteAccessibleGroupsValidation extends OgTestBase {

  var $dummy_content_type;

  var $group_node_1;
  var $group_node_2;

  var $group_owner;
  var $group_member;

  function setUp($modules = array()) {
    parent::setUp($modules);
    debug('pass');

    // Create group content.
    $this->backdropCreateContentType(array( 'name' => 'Group content', 'type' => 'group_content'));
    $this->backdropCreateContentType(array( 'name' => 'Group', 'type' => 'group'));

    $og_field = og_fields_info(OG_AUDIENCE_FIELD);
    $og_field['instance']['settings']['behaviors']['og_widget']['default']['widget_type'] = 'entityreference_autocomplete';
    og_create_field(OG_AUDIENCE_FIELD, 'node', 'group_content', $og_field);
    og_create_field(OG_GROUP_FIELD, 'node', 'group');

    // Create users.
    $this->group_owner = $this->backdropCreateUser(array('create group_content content', 'administer group'));
    $this->group_member = $this->backdropCreateUser(array('create group_content content'));

    // Create a group node.
    $settings = array();
    $settings['type'] = 'group';
    $settings[OG_GROUP_FIELD][LANGUAGE_NONE][0]['value'] = TRUE;
    $settings['uid'] = $this->group_owner->uid;
    $this->group_node_1 = $this->backdropCreateNode($settings);
    og_group('node', $this->group_node_1, array(
      'entity' => $this->group_member,
    ));

    $settings = array();
    $settings['type'] = 'group';
    $settings[OG_GROUP_FIELD][LANGUAGE_NONE][0]['value'] = TRUE;
    $settings['uid'] = $this->backdropCreateUser()->uid;
    $this->group_node_2 = $this->backdropCreateNode($settings);
  }

  /**
   * Verify that a user can't publish content into group that he isn't a member.
   */
  function testAuthenticatedUserCantReferenceToPrivateGroup() {
    $this->backdropLogin($this->group_member);

    // Try to publish content into group the user is not a member.
    $this->backdropPost('node/add/group_content', array('title' => 'New group content', 'og_group_ref[und][0][default][0][target_id]' => $this->group_node_2->title . '(' . $this->group_node_2->nid . ')'), 'Save');
    $this->assertText('The referenced group (node: ' . $this->group_node_2->nid . ') is invalid.', 'The reference to group the user is not accessible has achieved');

    // Try to publish content into group that doesn't exist.
    $this->backdropPost('node/add/group_content', array('title' => 'New group content', 'og_group_ref[und][0][default][0][target_id]' => 'foo (900)'), 'Save');
    $this->assertText('The referenced group (node: 900) is invalid.', 'The reference to group the user is not accessible has achieved');

    // Try to publish content into the group the user is a member of.
    $this->backdropPost('node/add/group_content', array('title' => 'New group content 2', 'og_group_ref[und][0][default][0][target_id]' => $this->group_node_1->title . '(' . $this->group_node_1->nid . ')'), 'Save');
    $this->assertText('Group content New group content 2 has been created.', 'The group content created successfully');

    // Testing the widgets my group and other groups.
    $this->backdropLogin($this->group_owner);

    $this->backdropPost('node/add/group_content', array('title' => 'New group content 3', 'og_group_ref[und][0][default][0][target_id]' => $this->group_node_2->title . '(' . $this->group_node_2->nid . ')'), 'Save');
    $this->assertText('The referenced group (node: ' . $this->group_node_2->nid . ') is invalid.', 'The reference to group the user is not accessible has achieved');

    $this->backdropPost('node/add/group_content', array('title' => 'New group content 3', 'og_group_ref[und][0][admin][0][target_id]' => $this->group_node_2->title . '(' . $this->group_node_2->nid . ')'), 'Save');
    $this->assertText('Group content New group content 3 has been created.', 'The group content created successfully');

    $this->backdropPost('node/add/group_content', array('title' => 'New group content 3', 'og_group_ref[und][0][admin][0][target_id]' => 'foo (900)'), 'Save');
    $this->assertText('The referenced group (node: 900) is invalid.', 'The reference to group the user is not accessible has achieved');

    // Try to publish content into the group the user is a member of.
    $this->backdropPost('node/add/group_content', array('title' => 'New group content 4', 'og_group_ref[und][0][default][0][target_id]' => $this->group_node_1->title . '(' . $this->group_node_1->nid . ')'), 'Save');
    $this->assertText('Group content New group content 4 has been created.', 'The group content created successfully');
  }
}

/**
 * Test for publishing content using a select widget.
 */
class OgSelectAccessibleGroupsValidation extends OgTestBase {

  function setUp($modules = array()) {
    parent::setUp($modules);

    // Create group content.
    $this->backdropCreateContentType(array( 'name' => 'Group content', 'type' => 'group_content'));
    $this->backdropCreateContentType(array( 'name' => 'Group', 'type' => 'group'));

    $og_field = og_fields_info(OG_AUDIENCE_FIELD);
    $og_field['instance']['settings']['behaviors']['og_widget']['default']['widget_type'] = 'options_select';
    og_create_field(OG_AUDIENCE_FIELD, 'node', 'group_content', $og_field);
    og_create_field(OG_GROUP_FIELD, 'node', 'group');

    // Create users.
    $this->group_owner = $this->backdropCreateUser(array('create group_content content', 'administer group'));
    $this->group_member = $this->backdropCreateUser(array('create group_content content'));

    // Create a group node.
    $settings = array();
    $settings['type'] = 'group';
    $settings[OG_GROUP_FIELD][LANGUAGE_NONE][0]['value'] = TRUE;
    $settings['uid'] = $this->group_owner->uid;
    $this->group_node_1 = $this->backdropCreateNode($settings);
    og_group('node', $this->group_node_1, array(
      'entity' => $this->group_member,
    ));

    $settings = array();
    $settings['type'] = 'group';
    $settings[OG_GROUP_FIELD][LANGUAGE_NONE][0]['value'] = TRUE;
    $settings['uid'] = $this->backdropCreateUser()->uid;
    $this->group_node_2 = $this->backdropCreateNode($settings);
  }

  /**
   * Verify that a user can't publish content into group that he isn't a
   * member of (either admin or not).
   */
  function testAuthenticatedUserCantReferenceToPrivateGroup() {
    $this->backdropLogin($this->group_member);

    // Try to publish content into group the user is not a member.
    $this->backdropGet('node/add/group_content');
    $this->assertNoRaw('<option value="' . $this->group_node_2->nid . '">' . $this->group_node_2->title . '</option>', 'The reference to group the user is not a member of cannot be selected.');
    $this->assertRaw('<option value="' . $this->group_node_1->nid . '">' . $this->group_node_1->title . '</option>', 'The reference to group the user is a member of can be selected.');

    // Try to publish content into the group the user is a member of.
    $this->backdropPost('node/add/group_content', array('title' => 'New group content 2', 'og_group_ref[und][0][default][]' => array($this->group_node_1->nid)), 'Save');
    $this->assertText('Group content New group content 2 has been created.', 'The group content created successfully');

    // Testing the widgets my group and other groups.
    $this->backdropLogin($this->group_owner);

    $this->backdropGet('node/add/group_content');
    $this->assertNoRaw('<option value="' . $this->group_node_2->nid . '">' . $this->group_node_2->title . '</option>', 'The reference to group the user is not a member of cannot be selected.');
    $this->assertRaw('<option value="' . $this->group_node_1->nid . '">' . $this->group_node_1->title . '</option>', 'The reference to group the user is a member of can be selected.');

    // Try to publish content into the group the user is a member of.
    $this->backdropPost('node/add/group_content', array('title' => 'New group content 4', 'og_group_ref[und][0][default][]' => array($this->group_node_1->nid)), 'Save');
    $this->assertText('Group content New group content 4 has been created.', 'The group content created successfully');
  }
}

/**
 * Test group-audience field access settings.
 */
class OgAudienceFieldAccessOverrideTestCase extends OgTestBase {

  function setUp($modules = array()) {
    parent::setUp($modules);
  }

  /**
   * Test auto-attaching group-audience fields to the user entity.
   */
  function testAutoAttach()  {
    $type1 = $this->backdropCreateContentType();
    og_create_field(OG_GROUP_FIELD, 'node', $type1->type);
    $this->assertTrue(field_info_instance('user', 'og_user_node', 'user'), 'Field was added to the user entity.');

    // Check that a normal user cannot access this field by default.
    $permissions = array(
      'access content',
      "create $type1->type content",
      'administer group',
    );
    $user1 = $this->backdropCreateUser();
    $this->backdropLogin($user1);
    $this->backdropGet('user/' . $user1->uid . '/edit');
    $this->assertNoRaw('id="edit-og-user-node"');

    // Change field to use entity access instead.
    $instance = field_info_instance('user', 'og_user_node', 'user');
    $instance['settings']['behaviors']['og_widget']['access_override'] = TRUE;
    field_update_instance($instance);

    // The field should now be present.
    $this->backdropGet('user/' . $user1->uid . '/edit');
    $this->assertRaw('id="edit-og-user-node"');
  }

}

/**
 * Verify OG group ref field support delta after saving.
 */
class OgAudienceFieldDeltaTestCase extends OgTestBase {

  function setUp($modules = array()) {
    parent::setUp($modules);

    $this->groupType = $this->backdropCreateContentType();
    og_create_field(OG_GROUP_FIELD, 'node', $this->groupType->type);

    $this->groupConentType = $this->backdropCreateContentType();
    og_create_field(OG_AUDIENCE_FIELD, 'node', $this->groupConentType->type);
  }

  /**
   * Test after creation we can access values using entity metadata wrapper with
   * the get method.
   */
  function testEntityMetadataWrapperForOgAudienceField() {
    $group = $this->backdropCreateNode(array('type' => $this->groupType->type));
    $node = $this->backdropCreateNode(array('type' => $this->groupConentType->type));

    $wrapper = entity_metadata_wrapper('node', $node);
    $wrapper->{OG_AUDIENCE_FIELD}->set(array($group));
    $wrapper->save();

    $this->assertEqual($wrapper->{OG_AUDIENCE_FIELD}->get(0)->getIdentifier(), $group->nid, 'The delta method returned the expected group ID.');
  }

}
